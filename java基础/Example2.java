/*位移运算符(要做位运算，首先要把数据转换为二进制)；
计算机存储数值就是二进制，位运算符直接对二进制数操作（接近底层），可以提高程序运行效率。
&:对两个整型操作数中对应位执行布尔代数，两个位都为1时输出1，否则0。
|:对两个整型操作数中对应位执行布尔代数，两个位都为0时输出0，否则1。
^:对两个整型操作数中对应位执行布尔代数，两个位相等0，不等1。
~:对一个整型数据操作取反。
>>：对一个整型数据往右位移，若为正数在高位补0，负数则在高位补1.
<<:对一个整型数据往左位移，在低位补0.
>>>:对一个整型数据无符号右移，无论正负在高位补0.
*/

public class Example2{
  public static void main(String[] args){
    int i1=1;
    int i2=2;
    int i3=55;
    byte i4=-1;
    System.out.println(i2^i1);//i2:0000 0010;i1:0000 0001 结果：0000 0011;
    System.out.println(i2^i3^i3);//一个数对另一个数异或两次值不变（可用于加密文件）；
    System.out.println(i1>>5);//相当于这个数/2^5;
    System.out.println(i1<<5);//相当于这个数*2^5;
    System.out.println((byte)i4>>>1);//结果为2147483647；byte的底层为int型；
    System.out.println(~i1);/*
    1的二进制：0000 0001；取反：1111 1110；
    1111 1110等于几呢
    按照负数：该数正数的反码的补码；负数的补码是+1，正数不变
    所以1111 1110减去1，再取反为1111 1101---0000 0010=2；
    所以1111 1110=-2；
    */
     i1=i1^i2;
     i2=i1^i2;
     i1=i1^i2;
    System.out.println(i1+"  "+i2);//异或运算符还可以交换两个变量的数值；

  }
}
